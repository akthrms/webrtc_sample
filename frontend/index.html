<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>WebRTC Sample</title>

    <style>
      .center {
        text-align: center;
        margin: 0 auto;
      }
    </style>

    <script
      src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js"
      defer
    ></script>
  </head>

  <body>
    <div class="center" x-data="app()">
      <h1>WebRTC Sample</h1>

      <div>
        <div>
          <button type="button" x-on:click="startVideo()">Start Video</button>
          <button type="button">Connect</button>
          <button type="button">Hang Up</button>
        </div>
        <br />
        <div>
          <video
            id="local_video"
            autoplay
            style="width: 240px; height: 180px; border: 1px solid black"
            x-ref="localVideo"
          ></video>
          <video
            id="remote_video"
            autoplay
            style="width: 240px; height: 180px; border: 1px solid black"
            x-ref="remoteVideo"
          ></video>
        </div>
      </div>

      <div>
        <h2>SDP to send:</h2>
        <div>
          <textarea
            id="text_for_sending_sdp"
            rows="8"
            cols="80"
            readonly="readonly"
            x-model="textForSendingSdp"
          ></textarea>
        </div>
      </div>

      <div>
        <h2>SDP to receive:</h2>
        <div>
          <button type="button">Receive remote SDP</button>
        </div>
        <br />
        <div>
          <textarea
            id="text_for_receiving_sdp"
            rows="8"
            cols="80"
            x-model="textForReceivingSdp"
          ></textarea>
        </div>
      </div>
    </div>

    <script>
      function app() {
        return {
          textForSendingSdp: "SDP to send",
          textForReceivingSdp: "",

          localMediaStream: null,
          rtcPeerConnection: null,
          negotiationNeededCounter: 0,

          async startVideo() {
            try {
              this.localMediaStream =
                await window.navigator.mediaDevices.getUserMedia({
                  video: true,
                  audio: false,
                });
              await this.playVideo(
                this.$refs.localVideo,
                this.localMediaStream
              );
            } catch (e) {
              console.error(e);
            }
          },

          async playVideo(video, mediaStream) {
            try {
              video.srcObject = mediaStream;
              await video.play();
            } catch (e) {
              console.error(e);
            }
          },

          prepareNewConnection(isOffer) {
            const rtcPeerConnection = new RTCPeerConnection({
              iceServers: [{ urls: "stun:stun.webrtc.ecl.ntt.com:3478" }],
            });

            rtcPeerConnection.ontrack = (event) => {
              this.playVideo(this.$refs.removeVideo, event.streams[0]);
            };

            rtcPeerConnection.onicecandidate = (event) => {
              if (!event.candidate) {
                this.sendSdp(rtcPeerConnection.localDescription);
              }
            };

            rtcPeerConnection.onnegotiationneeded = async () => {
              try {
                if (isOffer && this.negotiationNeededCounter === 0) {
                  let offer = rtcPeerConnection.createOffer();
                  await rtcPeerConnection.setLocalDescription(offer);
                  this.sendSdp(rtcPeerConnection.localDescription);
                  this.negotiationNeededCounter++;
                }
              } catch (e) {
                console.log(e);
              }
            };

            if (this.localMediaStream) {
              this.localMediaStream.getTracks().forEach((track) => {
                rtcPeerConnection.addTrack(track, this.localMediaStream);
              });
            }

            return rtcPeerConnection;
          },

          sendSdp(rtcSessionDescription) {
            this.textForSendingSdp = rtcSessionDescription.sdp;
          },

          connect() {
            if (!this.rtcPeerConnection) {
              this.rtcPeerConnection = this.prepareNewConnection(true);
            }
          },

          async makeAnswer() {
            if (!this.rtcPeerConnection) {
              return;
            }

            try {
              let answer = await this.rtcPeerConnection.createAnswer();
              await this.rtcPeerConnection.setLocalDescription(answer);
              this.sendSdp(this.rtcPeerConnection.localDescription);
            } catch (e) {
              console.error(e);
            }
          },
        };
      }
    </script>
  </body>
</html>
