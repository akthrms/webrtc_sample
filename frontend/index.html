<!DOCTYPE html>
<html>
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
    <title>WebRTC Sample</title>

    <style>
      .center {
        text-align: center;
        margin: 0 auto;
      }
    </style>

    <script
      src="https://cdn.jsdelivr.net/gh/alpinejs/alpine@v2.x.x/dist/alpine.min.js"
      defer
    ></script>
  </head>

  <body>
    <div class="center" x-data="app()">
      <h1>WebRTC Sample</h1>

      <div>
        <div>
          <button type="button" x-on:click="startVideo()">Start Video</button>
          <button type="button" x-on:click="connect()">Connect</button>
          <button type="button" x-on:click="hangUp()">Hang Up</button>
        </div>
        <br />
        <div>
          <video
            id="local_video"
            autoplay
            style="width: 240px; height: 180px; border: 1px solid black"
            x-ref="localVideo"
          ></video>
          <video
            id="remote_video"
            autoplay
            style="width: 240px; height: 180px; border: 1px solid black"
            x-ref="remoteVideo"
          ></video>
        </div>
      </div>

      <div>
        <h2>SDP to send:</h2>
        <div>
          <textarea
            id="text_for_sending_sdp"
            rows="8"
            cols="80"
            readonly="readonly"
            x-model="textForSendingSdp"
          ></textarea>
        </div>
      </div>

      <div>
        <h2>SDP to receive:</h2>
        <div>
          <button type="button" x-on:click="onSdpText()">
            Receive remote SDP
          </button>
        </div>
        <br />
        <div>
          <textarea
            id="text_for_receiving_sdp"
            rows="8"
            cols="80"
            x-model="textForReceivingSdp"
          ></textarea>
        </div>
      </div>
    </div>

    <script>
      function app() {
        return {
          textForSendingSdp: "SDP to send",
          textForReceivingSdp: "",

          localMediaStream: null,
          rtcPeerConnection: null,
          negotiationNeededCounter: 0,

          async startVideo() {
            this.localMediaStream =
              await window.navigator.mediaDevices.getUserMedia({
                video: true,
                audio: false,
              });
            await this.playVideo(this.$refs.localVideo, this.localMediaStream);
          },

          async playVideo(video, mediaStream) {
            video.srcObject = mediaStream;
            await video.play();
          },

          prepareNewConnection(isOffer) {
            const rtcPeerConnection = new RTCPeerConnection({
              iceServers: [{ urls: "stun:stun.webrtc.ecl.ntt.com:3478" }],
            });

            rtcPeerConnection.ontrack = (event) => {
              this.playVideo(this.$refs.remoteVideo, event.streams[0]);
            };

            rtcPeerConnection.onicecandidate = (event) => {
              if (!event.candidate) {
                this.sendSdp(rtcPeerConnection.localDescription);
              }
            };

            rtcPeerConnection.onnegotiationneeded = async () => {
              if (isOffer && this.negotiationNeededCounter === 0) {
                let offer = rtcPeerConnection.createOffer();
                await rtcPeerConnection.setLocalDescription(offer);
                this.sendSdp(rtcPeerConnection.localDescription);
                this.negotiationNeededCounter++;
              }
            };

            rtcPeerConnection.oniceconnectionstatechange = () => {
              switch (rtcPeerConnection.iceConnectionState) {
                case "closed":
                case "failed":
                  if (this.rtcPeerConnection) {
                    this.hangUp();
                  }
              }
            };

            if (this.localMediaStream) {
              this.localMediaStream.getTracks().forEach((track) => {
                rtcPeerConnection.addTrack(track, this.localMediaStream);
              });
            }

            return rtcPeerConnection;
          },

          sendSdp(rtcSessionDescription) {
            this.textForSendingSdp = rtcSessionDescription.sdp;
          },

          connect() {
            if (!this.rtcPeerConnection) {
              this.rtcPeerConnection = this.prepareNewConnection(true);
            }
          },

          async makeAnswer() {
            if (!this.rtcPeerConnection) {
              return;
            }

            let answer = await this.rtcPeerConnection.createAnswer();
            await this.rtcPeerConnection.setLocalDescription(answer);
            this.sendSdp(this.rtcPeerConnection.localDescription);
          },

          onSdpText() {
            if (this.rtcPeerConnection) {
              const answer = new RTCSessionDescription({
                type: "answer",
                sdp: this.textForReceivingSdp,
              });
              this.setAnswer(answer);
            } else {
              const offer = new RTCSessionDescription({
                type: "offer",
                sdp: this.textForReceivingSdp,
              });
              this.setOffer(offer);
            }

            this.textForReceivingSdp = "";
          },

          async setOffer(rtcSessionDescription) {
            this.rtcPeerConnection = this.prepareNewConnection(false);
            await this.rtcPeerConnection.setRemoteDescription(
              rtcSessionDescription
            );
            await this.makeAnswer();
          },

          async setAnswer(rtcSessionDescription) {
            if (!this.rtcPeerConnection) {
              return;
            }

            await this.rtcPeerConnection.setRemoteDescription(
              rtcSessionDescription
            );
          },

          hangUp() {
            if (
              this.rtcPeerConnection &&
              this.rtcPeerConnection.iceConnectionState !== "closed"
            ) {
              this.rtcPeerConnection.close();
              this.rtcPeerConnection = null;
              this.negotiationNeededCounter = 0;
              this.cleanVideo(this.$refs.remoteVideo);
              this.textForSendingSdp = "";
            }
          },

          cleanVideo(video) {
            video.pause();
            video.srcObject = null;
          },
        };
      }
    </script>
  </body>
</html>
